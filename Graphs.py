gAAAAABfUnPY9veMD1WVxpQorEZDq7f41EzzpmTZeALdHtwb4Rf4tOBIXk-gvmQGZbPZePfdnlvd3LlwI7UAnAFB2rRSLwLMzA0Eg8fXVKFKQYVaJRKnDznzFtyaHJrT_CyZC1AiFeZvx5z7tCnxWdpg4WkGYPa6T3Aj3NZif53lqaH6OLNmHzsoYAF5XEmaLHjCONt4YxOQCa90v-ETdn8Y-lHJ2zmxpKVHiVo_7fCqIWM0P2jDMetVnrnlVHf6JBbzRMHJ5KhOS4c-VA97ryEBmbjHURzabBIwHiQqc7FElZi4ZMJRFhg_uLTgSYWidMqeTGmuwoVS6A-H-bcVNaFAFPDRc8W3Yn2VCOJQrwOwLiC8p8pUBIoWu19XvKS-_bnQdUDbhtLHTOhVE4wDcgfGhXZl3cCSlGqzmReThVYnDkrvid_-Gda-NTwGU7L0aO2xtAZimB_M4PDSPDEGClUAtnxELDSG8QKU3C_elbYZMob2eWyB6OhlKBAwodPTDe-Iql_CGMqlzbE0Li_mHyF3PkF76f1WcLCbh7g-Lp7xWduojq99PUqEZfaxmpcO0mRmJ0qTmFMPrzJ5TfWqG0AAuWht0XxBacyNy-mQbrrjYCsl3L_DOa0CKR_mhnUKZjBsemBxGjWkLxE4enel1WiiS8KejeWawpROlewhb59AzulbWLqab4n_wPKvA98ILlX1Tucbm0IujDYoQdu4hV9K6iOQSEkijTXpwqttMJJ6clTlQMrPsiANmU33o2Db2Xm4leav15GjhecTYDOp_v7MsR2WdVe8nbWocW0qYRwEo6vVlt98yMR-P_rug5B8JG_lkd-jlMHrDNvFRFT2tw0Jk9S7TvMreW6DKGqgLIkSmrb0_H-DQ8LHnSSOCZZt36gMaLw1WUIJimtqGYxSs39L0Isrsshelr8TUx3GmvMDqRQfYRKLnZx7BIoyQuJ5Wb9OpVPfDm2lvRed7rY-KuC-J1_ZPB-4MDJhMMOYYcu_txRISCd5JcTGqNrgE4eZqXOL6nodKciMdvHwgH7LPlcrmx81r65aoHP3o1j9zRyFjnCvpVmqiCqEn9Xpi16rq5Miknz5qhlC8XR91s9l7gal4ZoXe9wMXZFtG5iGPLy83G1zIw_ft3xrzjq9GQNluzsJ2-VYQfr65sJNeuPWXAk1yIGCgaoE_IAUxcMEsbVOYrTAhQQV4-4nrfmf-6jbIgP2fXIJdYGax6bPkJzEBbZXp9F0d32V-gyRZDI1ZmYJej9sO9_m6ZZXBWSg63HdnkPbkRS8YMqHRhdH8tMuNhihwtU_OmFW3fr0TVhfMWPmQQDEdVQGA-M1P9IdAgpUoVMagEbOZXLpvr0NbiG7Is4lU_i02dsUdp9rgvmxTIgTP8I7EyiMMQyHTBvQmNDNbKxC43Nw-ZdiLc897AHxhcb551x2evhBxosBwoAG2w-hIcQoXinvQArD4rqT7Xr0WzBIsxTyLZqXQz1kN0Vre7KeytcQiDacKKzt5TiiQ44ltvMFTmyDHKqKnkfwElxcL3J8rr508uyuJNuCOB8sv2qWw9yUKwzZvfokVg9hbBIP0Sp_jyK4UatR-fIXESk8Yy79jwugwgwuA-rIL5AjnK8H8-sWUWyGS-BXQsISWDHpiILVOlAYjH4ORUXHLi16SaEYwhlXWHiUiz4HvIQiTJqzkkc4eVqB0OljXi78CAMZUCX0hksl44XhHyK3qc7Z31xhljCqk40xWIHpb8l92V604w-fcZiRdxxMvI4DxlDyMX2UXJiZDTIJWhwC0QG1IsCYaQR0DZ1zjUf3nLDNAjQbtBeX0khVg6wpKmH3bpAlO4dJf53qYHeyZjHrUQQTEkZFU_o6aZ5TjFNpH7_nc5JpNEWusJ5a_XOiw_hgDi6mtPObghVm2lcx-ZNDKsjFUFs-0Yr_U1k28KbRYl97qSzkE08Tpd-2ysHPZxfPJMvaEzj6pM7lIYr1iLbwDHKJFMFsHXpeaYpXHVCg1nExrWUb30jY099QPCAf4YfCWoaicq8q50r_H8TLJ4H_IctoHm2UmteB14VLrXxLUUtxnsd_8qn6BLDbX5vya_p486TtMJ8wnThUfkPAWjkcPhpE-IhLWvdCfWKcR3n8qPs1jtXxl8o3fimHyCpXWhDy0v7jaYuPxOCV7vgrwWHLdK5Sg7AqE-bERzCmJoE5IXL7S36-ozD0ZJfpGqffUWL2n_6lzEtW6nx0jxpCh6K7HWb6rr9Pu8FLEMBXDsai2udDZZGg1k4c3u3rvG12xZoedAHfD3eIF6EeqNBR7vZAL1eMznIagHqUIkNjITJoOpg1R8wXkLhxWgGoaozv_iUc3lNCFzI8GPOR_uozIPzRMwB_FaL6dxV5UjEr0w6XMDLkQyM8nR2bCz1cH68zNOoy3ZuGEIHMJzVDhb3Op6vnQTKb76_JxMZeRe9YjQI-XBbWFyx81Lf8wM6YUbNAIMLIH2qCTQNVF923mMdl7jvCb4Lq-Yr1o7e2eTTHguJ7b3c3vsM42JOUsK1_TttRwmiUR5GGjld_3p0KDbWDj0bGcXq_csTYnFLIbAK6WH3GbQpRR84Cx54O9ptEwH8xDNoZMfV9VUQxW1hasCQi46MI-pyUsdZxV8-FtgsCmU9jYeUtjB-NQhGspI7slwsLMhPzrlpnyAlla58t0_xiLiUzkDNvdqYh87EUPt2T0BPvuq_2TXO9-LflHZwqofzcBX5YxJVeTki0w20Da6YhgisR2UiyfTrsrff_Tdhn16wolyO4DysiCbE8OvDjkYEIUADxs-kueKEBL4LH8dE27Edla3aiOurFqv8i68V5_tpZSejhZOJjhHCslIpSqdt-uY30nFjfpEZ-lfArnPCzfpSY9ySgbz4D0nuJetkKBNAr8furvzcNadpJImnLlzMas7T3QlDJgV2Fdfoc4YaP5qa4tfLJ-GLiSvsDri59WyDguaQ4Y60PCy8Y_BUHeU6qsw3d92zY26XXL1USaOpT3_3YvnoQJXbcMQbjxtXliW6ntvLgWxZu3f3WWk68YawkZKtbh0slkBwwy1sbozwMA8Ved_OUWj_Zw7gOQPAqeH_V4cbU22mHEHOeLc9rF6s6Nx_SXPL2GNwoQn9cLDAxTU_Q2zLXzCft7wH_6Th1yAVwyFAmd1NhuAhsa0JKwf41e9L6aljjQncUnnPl4DbY7_aAFHek5jGtSxps-m4szaQI9lwQ6UJDTMdCi-TqbzEZJfqJ8F89bdKrv1xB4DvFgsHsfdnC4ucYO-xgLulvC2U3_HzNWWsqxyAQ_PodQQEvvoogmW3o1uO38gvTiFEMsLqrfCh0ug8sUj1lqm604ZlCv5bpdnK-NSCQbt_2FnENunujyWTi9Cig0PLuD_MqMw90w30MYBIVGpd2MXo0QuERwZRG0YIVGnLv5_qO0hq3rmo1HemKnVEX6gbEdH6tZbIhuaBi1gz_NkxA1WbMNBtOXHlrj7ny_pkK-NAD5rU56JsM28VhLRf-hE7vYKK3Csp2IGOQ7QJwa3RPBA_YiEfEqqSMUayJAGkI0JD9LK5KJwHeGML5C8znDOiGffsdMxvDwvPX6SVOJSp1zYjZORCzavoIKKUC-4g7PlSFgsAqG1Oi5ZEwRLf8uv0GMVUNLVi4-7aVN9yj7MFwgjBzwmU4z5LD1QAn_MXDrw4u8Ifzu-W3hePUUb-T87ZyqWYGmgrG_n49kuq--UFuHpByH-ApqMnaAzFUxtMw-3QFq1Mc4JceoK6rwQhETgGXG8iiuM-mZNRdKdiblFhxs4WHby-NNkIFACg8t5p6NTnJv6X7Zhioq-Ua_-Adfb2WlIeI-RzmLcGPktxLk5esKs6WyZzxzfHStXI5Mkj43O75xYS4MsbVGHvK4gsL7A1ziJ6okp3BXxIMM4XiZJBSfpZGSKk8ZzY4BguNNGJgisgiGzKPH4I0HdKo6dpIK1Tqrz88RhrTpeIjPDyud6xARj2tp50doMgb--dry7TKyqhbeA5QOzkHS49XXVLDhDPaPNVPx_UR_53goQuvwV2KEwvem220025JcnXUnIZ7uMeP07s_eqkZiGER5UmGVTAl7FmwjtmClcAZC0zz-JLeGYAtsqiy39Kxc4NI3abFulYpY6dkQH23yHGCJLTKuYYMLsT-uxMJby8xwKnB22GExvIHSnadlGIZigWBg6OqAGimMoYMV_gf7cjbIxHqDSiBG0gpUCjO6t3B9UJXL3ItPd00KY19nA-bk1hQc8PvstsXC8VKcH0zSN2-eHC1h2bbzpjboiFLLjnYAn9Ka8srvk96Hw1Hp9SlOxeyRBsRYdd5J3c2wpuove2d-hiC0VWna05Dsu7fsqt3ZLY5vuBHdaWSuePXqfgtPgGZb8yBqSWpcYFZaxUtuSlPD6P70IVFchum8-gjqmqO3BCRSeKETL6GbZlXdJfulpo1Fud2SpIr5HPtVahEITFj--whfteA2g4XxqSSRjE4kQK6N8dGnyeIzh371G1qVhWoKn_RLpoeiROcsSkF3iHsjoRfwqP_stF7rCKmg0RxefuQ6-Y9wEw1dFaA_B94eVHcLen32gYyddAjATrAMvvGzGbIqKtSf5Z6bs2aboQvZZa67bWsClvIRieceWGLx4P-mYfG3Sv-JR3bWFVS1w8EbUSe5yQ0wLldtrFEDuMH_9e7p-cbxqZS2lHXpGUVR4R6TC7522_qyk3LJUn2ffSJEkWyUWhCgCPR9SGnAnyzKHeh_tOryA1Zp7XKdSxVFx-k8C8HQw2JxSzHOC841DFGXRxfzKGeeq-wtShTYqADsCOailbpczXNXfW4rb3Q79nhJMsrM0M9FbwVS1HqS6RTEUuNmLYJ6TuI81pP9MeUQ76ogHzRwe8aGF8czNGiKPU6kPsQAaxVyafUBqcUaJy9dhruM33S9jIKo-8oBO20NqQByNylib-JmOQlWBzH4Twg-S3Xwu1v0IGwG--cZQk9SaZKuxzRoaM0l2m5rO4mfG24ZtUbaEqZ0-a2xJ4g5ST9r_086W-1o6NbkAyNPFgp2WTotQTkoIpch43AvEBHs8QS8nMWjLYIBXfJ3_LmElItZnF36NZslHY7cjEiXqJNhiSh33GQ4S1Fdy-sRpQsfIy_vmC6KCBkBRb7QsQLA-EXtXhPstcLCgikgtBzkB238LN61v2rIu8PmqiQmN2FEMEguMHF-XXeFJ87r5poils9F3lbyWvJ_tKEorM3e9aD0OHSrBsmBzzwdw49e-d1RaUICJ137hgtCWzHl_RnvZ_itCmn_VO4Vc7mU_VyvzXmwvPxweVStVVpJG6fIakfzGVS7uDlZcZYJcOrNv55Dg1rhRCU6IrvwtjBNjUUWTnArFWprUgBOap8jBmV8ATC1erXyPLFJlBRrawe1Du62mgCN2k2u0_Gtt-uYkjAg6cmOJfo_nNDel3G8EwZ5nE1mLqBOytmEqShwR3kb9ckAiZ1MK9TjwehXy2OhNyFVGXSxHvUU4JG8zYlRPpGH_jx3eCDmRrBsVEeIRbL9wMgvAUiUQziUt2wjAGym0S4Mbqyc6YS4r3ScOCgzoYNIYErxRirjxTGm1k2lDL74ZRDUDT_N8W9J5CrprUfxyc8SQ_e82cZc0eI0GHWMrKFLR20Z7SBFKIg5ReuwS1B57Djdk-QJGxhjVX-2UMHP_rH64h1zbCmhvSSqlwM8ESsTejMf7RzWPaSqlYAhOMHYHHRGyaSifwJ3U-7qg8mHHZ6onxyuApO7cWkb28fefyG2hxYgpUzQpZifkcwHM0SlXzEG7JQNE-Df7yfiTrmYamT84zyCKEyFcK4JBkKwHjFPnLgcFvzI5SJ0QHYPVcvUtfDWSspiSd8EXzDgXvR0JzU7yPW5B8JAR4kqjAit0RuDK4pEMyovsgqAgeIsi8HrBk1CRFGFnfFRMI3ZnocCWCdSCuEiHKuG8-WeB6dT9TbEtwqqqZbKGRXXfr9E40_lXEWsZnpWIVYtUf4Dg5Y-hep4YyxPMb8XCjpeSx7yylwmyXqyOKH0mxL-hYHgZh_e9Mshi0IeGDhFlkRgO2FdiuUuzU6LOeEuDtz0pMb3o2qOOQZKdM-DP6Zuw62ZqMzyZx4h7PDIXE81r3YO6DjHz_h02XnNB7unBJYAzbIPgkNTb_q4V0p9xAtjB6xzKOwFToNPZgIMDnvcjarWnTZZxjR4Ln6KcNfd8oUvLf-vkJLCNCt_tYVsZrBPqpxbz5kGYbYJBl8OBc_gf7ly8Poh91K-zCUKxJKJ77stjiWq59Iyrwa0N9vAOylkLfIQF06T_y52EiPaejINQDDaILs-6EqpyzlvnbJ7ujmIYjksU8vjkTCGwJp1gOcWb_h7a3u9urpva5e9PPUepqW8Om4WOkeaKYl8hTCH3ItPZjUIjNZRvNR7q6LybJISFs8nM2pcbt5FDm1pTLDa2vkPg4Lv71uYPglmgApjAq8_me8SRgMFCRb56vPv20i2NszZHFtaAQGyiuFfRMnwiI6GYGX7ijWTYsZ3TIOxG1d21loAYMtDkE-Rj3acmINmutROx1yHt7cylzEnIcl6uWYWwoP6ZwpWinPiIAnJLwltgJ_7VVj6EujtHiNKD7uZsq5po-TtYVUFuT2MHJo6Wwmz-RyhtFCeraxq512cAK2n0oQ4K1kiOnjlBagRFUWUby9y_D1FDfJ_aJYWJnWfipFO-yogVdKIY8-2sE7dI2VtGVGQkguA_U8R7K0SZXCX6qCTYsyVlNuGsplgqEtk_znCl-44nCaoojLvSwx-bb4NIuAQN3Qp1JnaK8eyRdJcwu3LGoEyXwhG-ot2qax_X3FC8O1QcXTBekv59ICFdZ4YknADrtjtGCaarnEa41DRo2SakNlKIIVK4ufj8J0pobCRUssygj01B03W-_WHBIeNvDvRwYLxxHcExL1doUGHJfVjI5mMlaMXjQVHin4alwGyDAGTbAgS4_CMa9qsmAoylbc_XnYjs5gy36DaYfLeAFR1x5n5Pej6ikFhX6a7YDZhF-bQ92lk79M-GABxtHbsqZA22PNY_lrAUMg9aviyx3lVmWI51f-OdZMrzGF2-B5CUt87_J9Kn_XKxx4Q-62AR1IlBdFoxkadQXkX3E5WkJDEe6PBo36nQpDUQHFHUuBqumnOD2VKePCuyZsr7Txta3-VqaouG0P0avlfkjbcz3AUlJkbxr_-gswUIagydjYrNIXytvHJOY49gMnLMJmM67CbCeNhiN2F5iHwk5Jf__K13ki-WSAgOEE2fE--BO47OJqy7hwOEQkLQquRCOl0wOqtPx0-2HxRN0rQzBD0GqBvIVLxghSXhOooCnDSFnjJ8Ii95gAOwjpOL7gouX3ne6LIFxswXNbzb4dz58IWwhEksdhFAUzVEU2p9gEWZ7FYFxmUqIEVh65ZGWkcnzJH-efgiW73igyBxq4fXIIELHyJ9vSHY6w3yc-VCZyG0y21kpkkW3wdBAU2N_EIlkrapoW-d1ol2mAJd-A4VA9F6cMh5pJ0hUy-h_N05_4aqDNBfnuCGrPSJf8LgmoQ7mt4xodhBY9eFXIdNT6fWFY3iKd_ELi5c9M1uIJgHea6LgZ3TdU-tu2GiKmxZPp_LFeyHyYkuOrqQY-mro4kAr2s7ZJywrf3HVb3d7bppR85cTs5r3DiMoiD6sfireSKPOplUloJ0yu6rRSXGhzutl2IJnxj-t3H2_ybAEvo30X8keO1ecf3Q-cF9EH1RnuZvLFteV_eLZgJo6Nxh3vVw1a1T5hWrnlis_M2VjpMyMrQaHZOIxGohkY6lPdrGDnI3QD0JRoYBx4OcrAktfRulrHNfHFYwzJCQZyfYrsznyvP0vhKj8W2eJdGJ7juNqb_b06nJHtPuKc4MTCSC6O9No3A7kGUs46RexThqhkjbWBAuKNPSU_GhI69F8RP1y-K7XKTC5xuWOHbmyDlI5JWXByzU5BOuaZDPH0sR4gDokTZYlo3TloUBXFu_MyIW227b3AN4pnLcUJqE35sZDigISmgNEdkQpw-lHOW4J6O8ltPUdjQpKiVQildljAYWPNDZXlBl0CbXorde4mQSkU1V8F827gxog-Pt2Zia8f7cScL5qpMBv4JkZqCQWVaI200gFlTV85XQBUIeVGGHt7X_pr_jPJUgFUYbblNK9syVFSGoxaqUSpW7iK7mL3eSb8OtAudNdoBz-Ii4JYVbbEzmpuDCSfIcVZO9J5LnZ-VH88-vS2jxSlsqBlcjoGHxYATXB1qHRtJ0uYWhUxkP_nMKIjYuHJPbYMJ73bPkmLhxzE-gGH5Kwrgi5Krd_tS6Qkk7B5ytLTZhqkOryoNekFUdscs3DvFoB0MM5DtYmAWKxmdzkAWCmWF9E30t0cMqwpX4qRZcquaZHTGnN2bxVr4L0QMdz65P2nodC0bsoKiLvk05oV2TIFK252hPHDud7Gt0vLpVENwydeW3kIOU_x6SAIKkpTZeBXbCpbqPPC4HlAMjZlq5a1Yuk-vFQtnkdFLMPtmj_i5cyFAhMx-39NryCguuk12t3nHtxN2zkhD41MMWKiPXk6o1g08yInp2wLLen7SR_vDbwjlfTq1Mgo6Awu4iVsaesx3ge81dsh148c_FVixDUUXFkTCa_c7sebGd4HHKL3jkCyZBXwdOsRELXZ_w-tuuiU3XpJ79fNVWghwUYFzSkBZV1ixzcxGVuUHDz4eYYvd8EgT2a0wdguwvjzBCqCoICXXC_RQBOUlbH8m_RN8FH9X964bnpe-irR1x8GVvnx_Cavcam5UqyPor7z2O4bPTXIMn3eJ_zUnwg2K2-00ySy0gvOk04njksTVpvz0rWIZgeEKlE6xiWFdpU0C_tyPvv1EmgPb3DtiweEKGmbVf0IOpCDOs-44b8DnzFVLekPq1C13wIqpx7NF09wfjoXqHww3AjpdPzIoGgwZmBnonKRXpxYHOIoIz2bTD1bdb6TYLmpXpa5uQY2yJj2J7KgAAKtuWLEH30-jOaj-Bx0YWs0ZA8f7sMUfaEqRoVRMpHtfpqNrYCQ9FKrW3NyVFj0L9BPaPJu1GjcfEVU9SQmvAALn5EqJp5j0jMv0-zfxnioosO4Qn5bnAURD0e9xpXbaWG9VACS1V4Ngse3gLF3a0wY4IbZh8yBjRC5NmLmzEKbVVIJddOLN2BGRy6RKg7xE5J4U-D1WzlmuzIdJ12sDU2hpdf1JgmDq8htbpnGFn9PPj_cNvTtFYp89HSi3Bo3E-SzLTesEVJkz4c872kbehe0xrcw9K0P_gd8Bo52TdCOjMrgcv-JJChiPuyAAd-k9X6QsL1voptZZQgOJ9ozuIS3i5l252zAXSbm7Rm1SxrQFyWYBg1NaN8e9r_X5hrdZLaf59Xp33r80w8KTr4a7Pz7zSaWdL-scY2F0zWhsopjo5NGrnms18r2tKHSK6BI0_Aj9XdgsOy1MjLSXXDG2TyNpfRqZy75M5gkcb9Yd9F6ecSDJS1z6PRaabooQqwbvPshOblvBjdlc0unSfKMyWubM7UkgJuCXvuTK1RptAIyXGEAiIw65WL9qNyRfWNOfFc8s5wW5RpJVcWpPMnab_KSiWnrHHeuuoILfA4rhjWz6j9t8JZxhD-IpBMgnSVysKN8sAG4hhp1qirKCyogRYsG6uFpu9WRkxZd7P-UdaL3iIV5kwMA22TXRk4o5WLsUYeNA5f3xcb_nWPgk-qfID8T45f_V7xIN0fJI1FHolUF2asLygO5qKXyKlmfSPOIeU4lSQdE3GguNIVailOz8bbBzc1DphoR6u_737JnSZBJX2TuDf1YutqjW8xnA-FLlLXiSo1lfPbb9PWr9ep128r0T1P52Wh782QQVxs_XXN_aEEmG0Z5gVvi2awi1AANmTTEUCbJsyPQAA131wVtAn-wSCtvIVQcFjT3MGqd8rW9uixIZC-LX7GKscTgj8-LlvgdOTJr2RSz73kDHBcLZmLAsyEyO0bl0-Uu3pw30q1LIl50-ht3H5fd5rPgZ3dWtNKV81Zpw57YkQrrvKmN3IPklcsnwL-zPjYHGA5D0eqhrnMLoZbLgDMw5YUa0wOkBSJ9ZFen7SzQFJLCISYoFF_ODWiZw53tuqL-lm1WvCQSnOtaRwQ4c8sLwf5bCYsKDH0A2cBOE7oMw2QAVCI8M9QpsbxpRy64Tjh0iIoi3ODna2kkcgyearlnB5BiFbSo8vKGJbe-QO36jJRoy5k9Dybm4GjJGChyF00t9M9aat08Un07R5PytHA3ULmoMvHfZo27iI1tRzGgqiL3c2U8mYujdX14mn7XwOKKsC4YN9rEJYYS1MJ1NgnK9Jv30vE1CCSv9F-XiAngcqvUIZdZGfWMa0gry1Y1LIKq1IgrktwbbyDYX0BdSRbz3WEQGKWOk78rE_p5Lg6819GkkKz7MCAetclm5AGkCiP6ChPkUTGerOgMAit9Zi_AKG9GnL0chPYkMFN4n7gqJPur00vC36A_aYzT4trfJ1_rHoRQ2FTC0EI2dv2n0GOU8HwVUgaVUvhacev7Ko2pvr28beDDYNduT7zwrpzsJZ44DDXctaGlSGb7R0bcpErkl9qI-4I-TrWYG_rM9r3cPanludctdpvltl0n6c-ZinqnKbiKfon3Kf9L3P1G-efkKdSb7-5ZOMxWTwOdNbw3jvL5Nf-odXsWw9dxfOv8sM2sulypcaxtjHgxg9XlWmAG6VwqSc7YZ7zAT7nVLxsaGi4bGTQsWlYCuRQhSEKa0f-vrlqiguBC10kCCUavmvHCTdpcXIIeMwNHHTp_JGsKpYWzMtfE69jjK6StN3owAUvbliGu7JlkLVgA7H_eNasQACko0_jo4znwFQvAHJWy2oQ6b2p8tb2SHLwLaWgLaiP2fYyPj3vtnRgI1v42MDUjeadRY4KRFi2d3IOthY2p3dTfqZQEv0_JpCElf2mUIH8YIcuKLwh8aODNll_xhvZWFRT8fr19zAZQywBZzuJDyswkIA932VG13A8bW2BfKn9PZ63x1DsqGKIIM-CEN3DpTqPgyKSBxMExtF6w-6YBJFvZeLdfZ4-eRbGhMcy9wjEg2V_SNEH_K7zsLfNC_UaPelpits1iXiEYK9ioco1cljFha14M1aq2YhEWO5t5G-8fI5JRYqBy_fJfBI807lcUQgTQ1o2vwRbvx3ElQNVjDykBVNxuI68w7FxErXBWTWG9kO2OZ_A5dHfw-e83_ldC67asD03fC2PmISkNPw8AniQMDlY85ULCdF_j3EaWQCqDpAN4EP2KqyZPYA-Kxy0pQunlveRWUpyOtU-Rw6e4V7XWAKXxSYtb2QSgCKFLln_bsoZ5kjmzYVSNHJ1JnCpebJjqOT6f_PWDRTmQWhR7IZ49DMhcmJC7g84FB7QWJfghwa8sKLTDH1aRIF-ca2TVV3TnPQRgF1hRttQseiQATIuobHlJHu-2OIn97-qUNUj6wNZ87j-yA9ouHQEZamCrwf9kW_J1lBPyYBhapjQ41R0ji6UdgfqIPyfju6AKqg7ySp5pm4FoAiehYB9adtnJGiR4Z9MXClKl3IPKBzT6RyQ6o7JyV-8cNg4pdnSP_9kr8wcqSEuOlNOxxmo7FgbGqEXc-1bNqyfVDb_KMuOY9zsdH2wFktrjRqACPr3V6oeom5_WQzl7torJsGP_Ez4zlZMUpog8wEf9ZqwRrFIY5QEGwX0NwIattCZ9MjL6iAeMvRpE7ClYxDa9P5kEKKceYggTXubNlYEPPCEBSXqG3XsnbTm1RpSICMY9VgFvhWn1m4GADbdv4d_uv72ZiObfKjHjulfr1L_OlY0j9HGAwqSKbhBwU6GSxh9GiyEve6PXOdbHy1jqOdQFbuHQ9nDEuUpR0xz4da3BFyJQe6NqFouRrO_nBY1K-fYVBBtHEnjpyE30jNnnkvfv8XpKWaa7b3aGl2QpIh-hA4s7LtnJLHRfhLloN6-GE670a24VTfjcAnM4GkMlAjyfXaUIS2D2kH0_U4dfduqNyz9qkqympSSpVX0rfSD-GX-Z5pHFs-_-P2IL5rDSe03Ds4eUp7uNpkNlJNUq-lSp5bm9Tv8G3bKX7uRDTdN7H_ZFftfCSBxjGTFrckmuFo_wARVrsf_ZHY8QdoZWHXzc8yM8zf2vVdPX-BBwQJZyW0Sg88ta4zO-EzMxwXagHIfsEMIX7Fb4t9oT1l7Hd_EzoBsZuD5uot3UbVM7RWZGztCG8AGeUQg7S-qvM-vXqN2tg-jhIh8GQT7PsPYBkcXx6SCUwAljWFM7yMdjn_zmpculP8GNK-bDdZBIA9MNaW5PNxUZXmnZ2tdFyowQ3REaiv7-k4UUMObX6G5keCw4PwuhVwBrT0H1hHKQRPZXkoDRbIHaD1XpwwKkz-hoT_6gKn294BykK5ZhwFXwoyg_jBL4mBQFna796OoJ0TLgFFEn-p6hyTCv7EIYUf6zF545xlnrWI0uA9F_PdleIrk7WNrO1i_64WA2pBCUgL8bbqpCosF1vGpSu3ZeQ2DlTGNLx7GCrWKhAI1vAUOnvgIJ00uerwaP8nefYOEzbcmfTdVSaiWyQyx1YXj8wdACdUF6jvuhEFZxWJmc-ngCjuCS3Pb26WCiYY1vD0Ah5X7NN5UafDYVqgYkd8s5h8oIdijZpnIF6liZSh1aNMTHftXBxke5B2I2n4rNPANzObPIlKZ6gOzGGkMqIpHDDPybYgHmBQ70KmIxRL2I5nx9_lHXm_NCfzJ-B_EZtBGpeOSOo6jw_sTfTHJ6_LpEOCNlqhtu5ylUo7GCUEDcy5DtLJQZvL0LnhPCCj-DOwIuP-hTs_d5_VtXHwdzsanQv1_LNY1yoX7Pz6fVKi584cShHETnsbPIYPQ0L8UyIhbh9thwKeMK-ImPQWmkLRbvUyHvwwTCUbp4wL1S18AS1A1mEuKAaEuJlhW4mZZPd1XuHdvrwIgOZoumrDBp68NVSKLz2punCIKtdEymSgFBqt73yK9ME-2xrW26xAtNreSNo2uYMle_g5KFK7yMJMbsDvTDE63900F1-VMfee4oOfmZZcmSlENNxArSLnWejGOLawpFj1qBi6d3WehQ-ERheTO9mkuMSv4sMQjx1dx4zEa9pIeqcqWwd6Abm8hugkEQoG1BYV2VaANxxBlrn4hrrTVRmVjkpRha8mMGLy3Tn-XGWj0wLRHJYMmr5_pC4fv_WCGx3arV0ZjgMNZsoSwVNlGUqpqA43UPSX5QATCeSP_cy0bbUHA1rB-I3suVsQvCz3iWoJ17n_Ym7xmOWavJXUbb0v78tjZB11XXy8Rb29shk_fduDv_Idep8g93VzRVhQRzrXN7tQVhFOM6IUv9I_JlaC975WXRebjdeGGq85S04DFtFCUvUH2rD9hYFfINvkW8q9vu4MoW6-houxwepq_49KDTDf5q83-mZbbVPg7I-Uzf2J2yqwHLAOd5DBT7oUrhEUiYj6rCP0ubNvx30oFVrxdIymTfT9nJJzQ4tyITk6e8R3CMbnG5z7iCbvDV7SEvqOUbayEql6PCmp5Ia1AmWghZJhw1QJoPg_SiuL3X5FPgjUr2qOEt__4aFMGyLqmBvyRITOvmxwXR4cm1curiZRB6UEmtqOfjQfA32C_tXdYA8zHmY1nYCI_I05f9oIgZCLu8vBVys1TXRZoLeb6-Dl9XW-m7vJ5cC7hkBATdhfLMv4q1TJQoqgL1LhUQLZ2EA5b5w0kMonIxtOW0qx978OM4tN9bDs6eCwyE6sZLbUweyU85opBGq3ugzU0FXw5PllMF1CQya3O0TGKOwwz17VSmgSxgvuJ0YuzxBmFCJNIMbBOiAK2kfFPnLa9rs5nHk8pcqLkCR0nVjDabHwa-QQwGLZUcujAHt03aWkhctG6M7wepBh7y-NnmZGMISBCurD43FuK_mYMvx2Dxfd6OLoHYydfkAaldud6uqi0_8zExXeXv2qhKBrSWwM1FLvyM4YDpog6M3dL3ehF4ONo9ZrWkmhxkgBhyQKaQ9Epm8J4AwwApp1a3gmOPlT0xh4tWdYawynvju43uOg6I0iX5XXyrDBilTMRoOgroZNSrdrQ3DD-pPFLwoS8IWuEm_qcWzjU_VZzHMbIBktpob8tGcOm_LZF-p95hyR0O-bON-7_DndNWJMiP032HidjZv5ZHspKV-FJjWOKfFQLudFHcHVEh6_W0PprX73VGC2mgUSkBnLY0eFoVmbZSBhI1EdTApqMAfrUQ-m9JNBaZIlrCVdj1WfvYUVcd4yM8b3qxOP1ZEx1X2HCL5So54ekI1qk_KgwqGtzYsmtjKaYK666RBGIzj0S_2hS3Hop4pkTSRGFr26gEr5Jv74T2zzF7MLAn-UYcfsEJe0dyTgtLE3Nnm8OOzrhFB8bFJtj_e0ooJFbacuj_ZHzOn8hPMJA2eScTsz4dYwyME-avdJeoAZ5m2qDkmKwhRpsOdYoi6JBzDYTEj5NDtZhIo0b6akBbTG6HGUCOmGD0TTmphEDYZ7zG_N3JJogbiBip7SMdUzR5XdnAcFCC-BwS31SRGnWnxKS5f33UojVoUNCGQCvcgHLTdC1AFqwcOfU7Pp331Up9uvcBeVNsNFOGp6ji9JcswqWFiYL_ueHgQA2FweaIyrgULa-X6lxqqxMQN9iCsjtvHg==

class Vertex:

    def __init__(self, val):

        self.Value = val
        self.Hit = False
  
class SimpleGraph:
	
    def __init__(self, size):

        self.max_vertex = size
        self.m_adjacency = [[0] * size for i in range(size)]
        self.vertex = [None] * size
        
    def AddVertex(self, v):

        if None in self.vertex:
            elem = Vertex(v)
            self.vertex[self.vertex.index(None)] = elem
            return True
        else:
            return False
            
    def RemoveVertex(self, v):

        if v in range(self.max_vertex):
            self.vertex[v] = None
            for i in range(self.max_vertex):
                if self.m_adjacency[i][v] == 1:
                    self.m_adjacency[i][v] = 0
                    self.m_adjacency[v][i] = 0
            return True
        else:
            return False
            
    def IsEdge(self, v1, v2):

        if self.m_adjacency[v1][v2] == 1 and self.m_adjacency[v2][v1] == 1:
            return True
        else:
            return False
            
    def AddEdge(self, v1, v2):

        if -1 < v1 < self.max_vertex and -1 < v2 < self.max_vertex:
            self.m_adjacency[v1][v2] = 1
            self.m_adjacency[v2][v1] = 1
            return True
        else:
            return False
            
    def RemoveEdge(self, v1, v2):

        if -1 < v1 < self.max_vertex and -1 < v2 < self.max_vertex:
            self.m_adjacency[v1][v2] = 0
            self.m_adjacency[v2][v1] = 0
            return True
        else:
            return False

    def DepthFirstSearch(self, VFrom, VTo):

        if -1 < VFrom < self.max_vertex and -1 < VTo < self.max_vertex:
            finder = VFrom
            stack = []
            for i in range(self.max_vertex):
                self.vertex[i].Hit = False
            self.vertex[VFrom].Hit = True
            stack.append(VFrom)
            while stack:
                if self.m_adjacency[finder][VTo] == 1:
                    stack.append(VTo)
                    return stack
                else:
                    for i in range(self.max_vertex):
                        if self.m_adjacency[finder][i] == 1:
                            if self.vertex[i].Hit is False:
                                self.vertex[i].Hit = True
                                stack.append(i)
                                finder = i
                                break
                        if i == self.max_vertex - 1:
                            del stack[-1]
                            if stack:
                                finder = stack[-1]
            return []
        raise Exception('Indexes are out of range!')

    def BreadthFirstSearch(self, VFrom, VTo):

        if VFrom is VTo:
            return VFrom
        if -1 < VFrom < self.max_vertex and -1 < VTo < self.max_vertex:
            queue = []
            edges = {} 
            for i in range(self.max_vertex):
                self.vertex[i].Hit = False
            self.vertex[VFrom].Hit = True
            queue.append(self.vertex[VFrom])
            while queue:
                finder = self.vertex.index(queue.pop(0))
                if self.m_adjacency[finder][VTo] == 1:
                    queue = []
                    queue.extend([finder, VTo])
                    while finder != VFrom:
                        queue.insert(0, edges[finder])
                        finder = edges.get(finder)
                    return queue
                else:
                    for i in range(self.max_vertex):
                        if self.m_adjacency[finder][i] == 1:
                            if self.vertex[i].Hit is False:
                                self.vertex[i].Hit = True
                                queue.append(self.vertex[i])
                                edges[i] = finder
            return []
        else:
            raise Exception('Indexes are out of range!')   
            
    def WeakVertices(self):

        queue = []
        weak_vertices = []
        for i in range(self.max_vertex):
            if self.vertex[i].Hit is False:
                for j in range(self.max_vertex):
                    if self.m_adjacency[i][j] == 1:
                        queue.append(j)              
                while queue:
                    finder = queue.pop(0)
                    for k in range(self.max_vertex):
                        if self.m_adjacency[finder][k] == 1 and k in queue:
                            self.vertex[finder].Hit = True
                            self.vertex[k].Hit = True
                            queue = []
                            break
                        if k == self.max_vertex-1 and len(queue) == 0:
                            weak_vertices.append(i)
        return weak_vertices

import unittest

class Test_SimpleGraph(unittest.TestCase):
    
    def setUp(self):

        test.__init__(3)

    def test_AddVertex(self):

        test.AddVertex(1)
        self.assertTrue(test.vertex[0])
        self.assertEqual(sum(sum(test.m_adjacency,[])), 0)
        
    def test_AddEdge(self):

        test.AddVertex(1)
        test.AddVertex(2)
        self.assertEqual(sum(sum(test.m_adjacency,[])), 0)
        test.AddEdge(0, 1)
        self.assertEqual(test.m_adjacency[0][1], 1)
        self.assertEqual(test.m_adjacency[1][0], 1)
        
    def test_RemoveEdge(self):

        test.AddVertex(1)
        test.AddVertex(2)
        test.AddEdge(0, 1)
        self.assertEqual(test.m_adjacency[0][1], 1)
        self.assertEqual(test.m_adjacency[1][0], 1)
        test.RemoveEdge(0, 1)
        self.assertEqual(sum(sum(test.m_adjacency,[])), 0)
        
    def test_RemoveVertex(self):

        test.AddVertex(1)
        test.AddVertex(2)
        test.AddEdge(0, 1)
        test.RemoveVertex(0)
        self.assertEqual(sum(sum(test.m_adjacency,[])), 0)        

    def test_DepthFirstSearch(self):

        test = SimpleGraph(7)
        test.AddVertex(0)
        test.AddVertex(1)
        test.AddVertex(2)
        test.AddVertex(3)
        test.AddVertex(4)
        test.AddVertex(5)
        test.AddVertex(6)
        test.AddEdge(0, 1)
        test.AddEdge(0, 2)
        test.AddEdge(1, 3)
        test.AddEdge(1, 4)
        test.AddEdge(2, 5)
        test.AddEdge(4, 6)
        self.assertEqual(test.DepthFirstSearch(0, 6), [0, 1, 4, 6])
        test.__init__(7)
        test.AddVertex(0)
        test.AddVertex(1)
        test.AddVertex(2)
        test.AddVertex(3)
        test.AddVertex(4)
        test.AddVertex(5)
        test.AddVertex(6)
        test.AddEdge(0, 1)
        test.AddEdge(0, 2)
        test.AddEdge(1, 3)
        test.AddEdge(1, 4)
        test.AddEdge(2, 5)
        self.assertEqual(test.DepthFirstSearch(0, 6), [])

    def test_BreadthFirstSearch(self):

        test = SimpleGraph(7)
        test.AddVertex(0)
        test.AddVertex(1)
        test.AddVertex(2)
        test.AddVertex(3)
        test.AddVertex(4)
        test.AddVertex(5)
        test.AddVertex(6)
        test.AddEdge(0, 1)
        test.AddEdge(0, 2)
        test.AddEdge(1, 3)
        test.AddEdge(1, 4)
        test.AddEdge(2, 5)
        test.AddEdge(4, 6)
        self.assertEqual(test.BreadthFirstSearch(5, 6), [5, 2, 0, 1, 4, 6])
        test.__init__(7)
        test.AddVertex(0)
        test.AddVertex(1)
        test.AddVertex(2)
        test.AddVertex(3)
        test.AddVertex(4)
        test.AddVertex(5)
        test.AddVertex(6)
        test.AddEdge(0, 1)
        test.AddEdge(0, 2)
        test.AddEdge(1, 3)
        test.AddEdge(1, 4)
        test.AddEdge(2, 5)
        self.assertEqual(test.BreadthFirstSearch(0, 6), [])
        
    def test_WeakVertices(self):

        test = SimpleGraph(7)
        test.AddVertex(0)
        test.AddVertex(1)
        test.AddVertex(2)
        test.AddVertex(3)
        test.AddVertex(4)
        test.AddVertex(5)
        test.AddVertex(6)
        test.AddEdge(0, 1)
        test.AddEdge(0, 2)
        test.AddEdge(1, 3)
        test.AddEdge(1, 4)
        test.AddEdge(2, 5)
        test.AddEdge(2, 6)
        self.assertEqual(test.WeakVertices(), [0, 1, 2, 3, 4, 5, 6])
        test.__init__(7)
        test.AddVertex(0)
        test.AddVertex(1)
        test.AddVertex(2)
        test.AddVertex(3)
        test.AddVertex(4)
        test.AddVertex(5)
        test.AddVertex(6)
        test.AddEdge(0, 1)
        test.AddEdge(0, 2)
        test.AddEdge(1, 2)
        test.AddEdge(1, 3)
        test.AddEdge(1, 4)
        test.AddEdge(3, 4)
        test.AddEdge(2, 5)
        test.AddEdge(2, 6)
        test.AddEdge(5, 6)
        self.assertEqual(test.WeakVertices(), [])
        
if __name__ == '__main__':
  
    test = SimpleGraph(3)
    unittest.main(verbosity=2)


    def BreadthFirstSearch(self, VFrom, VTo):

        if -1 < VFrom < self.max_vertex and -1 < VTo < self.max_vertex:
            queue = []
            list_of_nodes = []

            def cleaning(VFrom):

                for i in range(self.max_vertex):
                    self.vertex[i].Hit = False
                self.vertex[VFrom].Hit = True

            def traversing(VFrom, VTo, queue, list_of_nodes, flag):

                queue.append(self.vertex[VFrom])
                while queue:
                    finder = self.vertex.index(queue.pop(0))
                    list_of_nodes.append(self.vertex[finder].Value)
                    if self.m_adjacency[finder][VTo] == 1:
                        list_of_nodes.append(self.vertex[VTo].Value)
                        return list_of_nodes
                    else:
                        for i in range(self.max_vertex):
                            if flag == 0:
                                if self.m_adjacency[finder][i] == 1:
                                    if self.vertex[i].Hit is False:
                                        self.vertex[i].Hit = True
                                        queue.append(self.vertex[i])
                                        break
                            else:
                                if self.m_adjacency[finder][-(1+i)] == 1:
                                    if self.vertex[-(1+i)].Hit is False:
                                        self.vertex[-(1+i)].Hit = True
                                        queue.append(self.vertex[-(1+i)])
                                        break
                if queue:
                    return list_of_nodes
                else:
                    return []
                    
            cleaning(VFrom)
            path_in = traversing(VFrom, VTo, queue, list_of_nodes, 0)
            cleaning(VTo)
            list_of_nodes= []
            path_out = traversing(VTo, VFrom, queue, list_of_nodes, 1)
            if len(path_in) > len(path_out):
                return path_out
            else:
                return path_in
        raise Exception('Indexes are out of range!')
